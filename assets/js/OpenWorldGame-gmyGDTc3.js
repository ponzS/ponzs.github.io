import{S as t,P as e,W as i,D as s,e as o,f as n,F as a,M as r,R as c,V as h,G as l,C as d,B as m,a as u,b as p,A as g,c as y,g as w,h as v,E as x,L as b,i as z,j as M,k as S,l as P,m as f,n as k,o as C,d as L,p as R,q as j,r as B}from"./three.module-DnDcNbJQ.js";import{s as A,r as T,C as E,D,l as G,q as F,u as I,p as O,V as H,B as K,A as V}from"./vue-CtS7YL1H.js";import{_ as W}from"./index-L16_EYrx.js";import"./vendor-D2VjgEpL.js";import"./gun-BMsQDwI5.js";class q{scene;camera;renderer;canvas;lights;constructor(n){this.canvas=n,this.scene=new t,this.camera=new e,this.renderer=new i({canvas:n}),this.lights={ambient:new o,directional:new s}}async init(){this.setupRenderer(),this.setupCamera(),this.setupLights(),this.setupScene()}setupRenderer(){const t=this.canvas.getBoundingClientRect();this.renderer.setSize(t.width,t.height),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.shadowMap.enabled=!1,this.renderer.setClearColor(0,1),this.renderer.outputColorSpace=n}setupCamera(){const t=this.canvas.getBoundingClientRect();this.camera.fov=75,this.camera.aspect=t.width/t.height,this.camera.near=.1,this.camera.far=1e3,this.camera.position.set(0,5,10),this.camera.updateProjectionMatrix()}setupLights(){this.lights.ambient.color.setHex(16777215),this.lights.ambient.intensity=.8,this.scene.add(this.lights.ambient),this.lights.directional.color.setHex(16777215),this.lights.directional.intensity=.3,this.lights.directional.position.set(50,100,50),this.lights.directional.castShadow=!1,this.scene.add(this.lights.directional)}setupScene(){this.scene.fog=new a(0,30,150)}add(t){this.scene.add(t)}remove(t){this.scene.remove(t)}getCamera(){return this.camera}getScene(){return this.scene}getRenderer(){return this.renderer}render(){this.renderer.render(this.scene,this.camera)}handleResize(){const t=this.canvas.getBoundingClientRect();this.camera.aspect=t.width/t.height,this.camera.updateProjectionMatrix(),this.renderer.setSize(t.width,t.height),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}dispose(){this.scene.traverse(t=>{t instanceof r&&(t.geometry&&t.geometry.dispose(),t.material&&(Array.isArray(t.material)?t.material.forEach(t=>t.dispose()):t.material.dispose()))}),this.renderer.dispose()}raycast(t,e,i){return new c(t,e).intersectObjects(i||this.scene.children,!0)}screenToWorld(t,e,i=0){const s=new h(t,e,i);return s.unproject(this.camera),s}updateLighting(t){const e=(Math.sin(.001*t)+1)/2;this.lights.ambient.intensity=.2+.3*e,this.lights.directional.intensity=.5+.5*e,e<.3?this.lights.directional.color.setHex(4286945):e<.7?this.lights.directional.color.setHex(16737095):this.lights.directional.color.setHex(16777215)}}class U{group;particles=[];particleGeometries=[];particleMaterials=[];trailParticles=[];trailPositions=[];velocity=new h;isMoving=!1;trailParticleCount=12;maxTrailLength=20;particleSpread=.2;constructor(){this.group=new l,this.createTrailSystem()}createParticleTexture(){const t=document.createElement("canvas");t.width=32,t.height=32;const e=t.getContext("2d");e.clearRect(0,0,32,32);const i=e.createRadialGradient(16,16,0,16,16,16);i.addColorStop(0,"rgba(255, 255, 255, 0.8)"),i.addColorStop(.2,"rgba(255, 255, 255, 0.6)"),i.addColorStop(.5,"rgba(255, 255, 255, 0.3)"),i.addColorStop(.8,"rgba(255, 255, 255, 0.1)"),i.addColorStop(1,"rgba(255, 255, 255, 0)"),e.fillStyle=i,e.fillRect(0,0,32,32);const s=new d(t);return s.needsUpdate=!0,s}createTrailSystem(){for(let t=0;t<this.trailParticleCount;t++){const t=new Float32Array(3*this.maxTrailLength),e=new Float32Array(3*this.maxTrailLength),i=new Float32Array(this.maxTrailLength);for(let a=0;a<this.maxTrailLength;a++){t[3*a]=0,t[3*a+1]=0,t[3*a+2]=0;const s=1-a/this.maxTrailLength;e[3*a]=.8*s,e[3*a+1]=.8*s,e[3*a+2]=.8*s,i[a]=2*s}const s=new m;s.setAttribute("position",new u(t,3)),s.setAttribute("color",new u(e,3)),s.setAttribute("size",new u(i,1));const o=new p({size:3,sizeAttenuation:!0,vertexColors:!0,transparent:!0,opacity:.7,blending:g,map:this.createParticleTexture(),alphaTest:.1}),n=new y(s,o);this.trailParticles.push(n),this.trailPositions.push([]),this.group.add(n)}}update(t,e){this.velocity.copy(e),this.isMoving=e.length()>.01,this.updateTrailParticles(t)}updateTrailParticles(t){const e=this.group.position.clone(),i=.001*Date.now();this.trailParticles.forEach((t,s)=>{const o=s/this.trailParticleCount*Math.PI*2,n=new h(Math.cos(o+i)*this.particleSpread,.1*Math.sin(2*i+s),Math.sin(o+i)*this.particleSpread);if(this.isMoving){const t=this.velocity.clone().multiplyScalar(-.2*(s+1));n.add(t)}const a=e.clone().add(n);this.trailPositions[s].unshift(a),this.trailPositions[s].length>this.maxTrailLength&&this.trailPositions[s].pop();const r=t.geometry.attributes.position.array,c=t.geometry.attributes.color.array,l=t.geometry.attributes.size.array;for(let e=0;e<this.maxTrailLength;e++)if(e<this.trailPositions[s].length){const t=this.trailPositions[s][e];r[3*e]=t.x,r[3*e+1]=t.y,r[3*e+2]=t.z;const o=1-e/this.maxTrailLength,n=o*(.8+.2*Math.sin(3*i+s));c[3*e]=n,c[3*e+1]=n,c[3*e+2]=n,l[e]=o*(2+1*Math.sin(2*i+.5*e))}else r[3*e]=0,r[3*e+1]=0,r[3*e+2]=0,c[3*e]=0,c[3*e+1]=0,c[3*e+2]=0,l[e]=0;t.geometry.attributes.position.needsUpdate=!0,t.geometry.attributes.color.needsUpdate=!0,t.geometry.attributes.size.needsUpdate=!0})}getGroup(){return this.group}setPosition(t){this.group.position.copy(t)}getPosition(){return this.group.position}dispose(){this.particleGeometries.forEach(t=>t.dispose()),this.particleMaterials.forEach(t=>t.dispose()),this.trailParticles.forEach(t=>{t.geometry.dispose(),t.material instanceof w&&t.material.dispose()}),this.particles.length=0,this.trailParticles.length=0,this.trailPositions.length=0}}class _{collisionObjects=[];playerBoundingBox=new v;tempBox=new v;tempVector=new h;playerRadius=.5;playerHeight=1.8;constructor(){this.updatePlayerBoundingBox(new h(0,0,0))}addCollisionObject(t,e){const i=(new v).setFromObject(t);switch(e){case"building":break;case"tree":i.max.y=i.min.y+.5;break;case"decoration":const t=.2;i.min.add(new h(t,0,t)),i.max.sub(new h(t,0,t))}this.collisionObjects.push({mesh:t,boundingBox:i,type:e})}updatePlayerBoundingBox(t){this.playerBoundingBox.setFromCenterAndSize(new h(t.x,t.y+this.playerHeight/2,t.z),new h(2*this.playerRadius,this.playerHeight,2*this.playerRadius))}checkCollision(t){this.updatePlayerBoundingBox(t);for(const e of this.collisionObjects)if(this.playerBoundingBox.intersectsBox(e.boundingBox))switch(e.type){case"water":return{hasCollision:!1};case"building":case"tree":case"decoration":const i=this.resolveCollision(t,e.boundingBox);return{hasCollision:!0,collisionType:e.type,adjustedPosition:i}}return{hasCollision:!1}}resolveCollision(t,e){const i=t.clone(),s=new h(t.x,t.y+this.playerHeight/2,t.z),o=e.getCenter(this.tempVector),n=new h;n.subVectors(s,o),n.y=0,0===n.length()&&n.set(1,0,0),n.normalize();const a=new h;e.getSize(a).multiplyScalar(.5);const r=this.playerRadius+Math.max(a.x,a.z)+.1;return i.x=o.x+n.x*r,i.z=o.z+n.z*r,i}checkRayCollision(t,e,i){const s=new c(t,e,0,i);let o=i;for(const n of this.collisionObjects){if("water"===n.type)continue;const e=new h;if(s.ray.intersectBox(n.boundingBox,e)){const i=t.distanceTo(e);i<o&&(o=i)}}return o}getGroundHeight(t,e){let i=0;for(const s of this.collisionObjects)if("building"===s.type){const o=s.boundingBox;t>=o.min.x&&t<=o.max.x&&e>=o.min.z&&e<=o.max.z&&(i=Math.max(i,o.max.y))}return i}clear(){this.collisionObjects=[]}getCollisionObjects(){return this.collisionObjects}setPlayerSize(t,e){this.playerRadius=t,this.playerHeight=e}}class N{gameScene;container;camera;player;collisionSystem;position;velocity;direction;rotation;cameraDistance=8;cameraHeight=4;cameraTarget=new h;keys={};mouseMovement={x:0,y:0};isPointerLocked=!1;moveSpeed=5;jumpForce=8;gravity=-20;mouseSensitivity=.002;verticalAngle=0;maxVerticalAngle=Math.PI/3;minVerticalAngle=-Math.PI/6;isGrounded=!0;playerHeight=1.8;playerRadius=.5;boundKeyDown;boundKeyUp;boundMouseMove;boundPointerLockChange;boundClick;constructor(t,e){this.gameScene=t,this.container=e,this.camera=t.getCamera(),this.player=new U,t.add(this.player.getGroup()),this.collisionSystem=new _,this.position=new h(0,5,10),this.velocity=new h(0,0,0),this.direction=new h(0,0,0),this.rotation=new x(0,0,0,"YXZ"),this.boundKeyDown=this.onKeyDown.bind(this),this.boundKeyUp=this.onKeyUp.bind(this),this.boundMouseMove=this.onMouseMove.bind(this),this.boundPointerLockChange=this.onPointerLockChange.bind(this),this.boundClick=this.onClick.bind(this)}init(){this.camera.position.copy(this.position),this.camera.rotation.copy(this.rotation),document.addEventListener("keydown",this.boundKeyDown),document.addEventListener("keyup",this.boundKeyUp),document.addEventListener("mousemove",this.boundMouseMove),document.addEventListener("pointerlockchange",this.boundPointerLockChange),this.container.addEventListener("click",this.boundClick)}onKeyDown(t){this.keys[t.code]=!0,"Space"===t.code&&this.isGrounded&&(this.velocity.y=this.jumpForce,this.isGrounded=!1,t.preventDefault()),"Escape"===t.code&&this.exitPointerLock()}onKeyUp(t){this.keys[t.code]=!1}onMouseMove(t){this.isPointerLocked&&(this.mouseMovement.x=t.movementX||0,this.mouseMovement.y=t.movementY||0,this.rotation.y-=this.mouseMovement.x*this.mouseSensitivity,this.verticalAngle-=this.mouseMovement.y*this.mouseSensitivity,this.verticalAngle=Math.max(this.minVerticalAngle,Math.min(this.maxVerticalAngle,this.verticalAngle)))}onPointerLockChange(){this.isPointerLocked=document.pointerLockElement===this.container}onClick(){this.isPointerLocked||this.requestPointerLock()}requestPointerLock(){this.container.requestPointerLock()}exitPointerLock(){document.exitPointerLock()}update(){const t=1/60;this.updateMouseLook(),this.updateMovement(t),this.applyPhysics(t),this.player.setPosition(this.position),this.player.update(t,this.velocity),this.updateCamera()}updateMouseLook(){this.isPointerLocked&&(this.rotation.y-=this.mouseMovement.x*this.mouseSensitivity,this.rotation.x-=this.mouseMovement.y*this.mouseSensitivity,this.rotation.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.rotation.x)),this.mouseMovement.x=0,this.mouseMovement.y=0)}updateMovement(t){this.direction.set(0,0,0),this.keys.KeyW&&(this.direction.z-=1),this.keys.KeyS&&(this.direction.z+=1),this.keys.KeyA&&(this.direction.x-=1),this.keys.KeyD&&(this.direction.x+=1),this.direction.length()>0&&this.direction.normalize();const e=new h;this.camera.getWorldDirection(e);const i=new h;i.crossVectors(e,this.camera.up).normalize();const s=new h;s.crossVectors(this.camera.up,i).normalize();const o=new h;o.addScaledVector(i,this.direction.x),o.addScaledVector(s,-this.direction.z),o.length()>0?(o.normalize(),this.velocity.x=o.x*this.moveSpeed,this.velocity.z=o.z*this.moveSpeed):(this.velocity.x*=.8,this.velocity.z*=.8)}applyPhysics(t){this.isGrounded||(this.velocity.y+=this.gravity*t);const e=new h(this.velocity.x,0,this.velocity.z),i=new h(0,this.velocity.y,0),s=this.position.clone();s.addScaledVector(e,t);const o=this.collisionSystem.checkCollision(s);o.hasCollision&&o.adjustedPosition?(this.position.x=o.adjustedPosition.x,this.position.z=o.adjustedPosition.z,this.velocity.x=0,this.velocity.z=0):(this.position.x=s.x,this.position.z=s.z);const n=this.position.clone();n.addScaledVector(i,t);const a=this.collisionSystem.getGroundHeight(this.position.x,this.position.z);n.y<=a+this.playerHeight?(this.position.y=a+this.playerHeight,this.velocity.y=0,this.isGrounded=!0):(this.position.y=n.y,this.isGrounded=!1);this.position.x=Math.max(-50,Math.min(50,this.position.x)),this.position.z=Math.max(-50,Math.min(50,this.position.z))}getGroundLevel(t,e){return 0}updateCamera(){const t=this.cameraDistance*Math.cos(this.verticalAngle),e=this.cameraHeight+this.cameraDistance*Math.sin(this.verticalAngle),i=new h(Math.sin(this.rotation.y)*t,e,Math.cos(this.rotation.y)*t);this.position.clone().add(i);const s=i.clone().normalize(),o=this.collisionSystem.checkRayCollision(this.position.clone().add(new h(0,1.5,0)),s,this.cameraDistance);let n=Math.min(o-.5,this.cameraDistance);n=Math.max(n,1);const a=n*Math.cos(this.verticalAngle),r=this.cameraHeight+n*Math.sin(this.verticalAngle),c=new h(Math.sin(this.rotation.y)*a,r,Math.cos(this.rotation.y)*a);this.camera.position.copy(this.position).add(c),this.cameraTarget.copy(this.position),this.cameraTarget.y+=1.5,this.camera.lookAt(this.cameraTarget)}getPosition(){return this.position.clone()}setPosition(t){this.position.copy(t),this.camera.position.copy(this.position)}getDirection(){const t=new h;return this.camera.getWorldDirection(t),t}getIsGrounded(){return this.isGrounded}getVelocity(){return this.velocity.clone()}setMoveSpeed(t){this.moveSpeed=t}setMouseSensitivity(t){this.mouseSensitivity=t}getPlayerMesh(){return this.player.getGroup()}getCollisionSystem(){return this.collisionSystem}dispose(){document.removeEventListener("keydown",this.boundKeyDown),document.removeEventListener("keyup",this.boundKeyUp),document.removeEventListener("mousemove",this.boundMouseMove),document.removeEventListener("pointerlockchange",this.boundPointerLockChange),this.container.removeEventListener("click",this.boundClick),this.isPointerLocked&&this.exitPointerLock(),this.gameScene.remove(this.player.getGroup()),this.player.dispose(),this.collisionSystem.clear()}}class X{gameScene;scene;collisionSystem=null;materials={};geometries={};constructor(t,e){this.gameScene=t,this.scene=t.getScene(),this.collisionSystem=e||null,this.initMaterials(),this.initGeometries()}initMaterials(){this.materials.ground=new b({color:3355443,transparent:!0,opacity:.6}),this.materials.building=new b({color:16777215,transparent:!0,opacity:.8}),this.materials.roof=new b({color:13421772,transparent:!0,opacity:.7}),this.materials.tree=new b({color:8947848,transparent:!0,opacity:.6}),this.materials.trunk=new b({color:11184810,transparent:!0,opacity:.7}),this.materials.stone=new b({color:10066329,transparent:!0,opacity:.5}),this.materials.water=new z({color:27028,transparent:!0,opacity:.7}),this.materials.road=new z({color:3092271})}initGeometries(){this.geometries.box=new M(1,1,1),this.geometries.cylinder=new S(1,1,1,8),this.geometries.sphere=new P(1,8,6),this.geometries.plane=new f(1,1)}generateWorld(){this.generateGround(),this.generateBuildings(),this.generateTrees(),this.generateDecorations(),this.generateRoads(),this.generateWater()}generateGround(){const t=new l;for(let e=0;e<=50;e++){const i=[],s=2*e-50;i.push(new h(-50,0,s)),i.push(new h(50,0,s));const o=(new m).setFromPoints(i),n=new k(o,this.materials.ground);t.add(n)}for(let e=0;e<=50;e++){const i=[],s=2*e-50;i.push(new h(s,0,-50)),i.push(new h(s,0,50));const o=(new m).setFromPoints(i),n=new k(o,this.materials.ground);t.add(n)}this.gameScene.add(t)}generateBuildings(){[{x:10,z:10,width:4,height:3,depth:4},{x:-15,z:8,width:6,height:4,depth:5},{x:20,z:-10,width:3,height:5,depth:3},{x:-8,z:-15,width:5,height:3,depth:4},{x:0,z:25,width:8,height:6,depth:6},{x:-25,z:-5,width:7,height:8,depth:5}].forEach(t=>{this.createBuilding(t.x,t.z,t.width,t.height,t.depth)})}createBuilding(t,e,i,s,o){const n=new l,a=new M(i,s,o),c=new C(a),d=new L(c,this.materials.building);d.position.set(t,s/2,e),n.add(d);const u=new r(a,new R({visible:!1}));u.position.set(t,s/2,e),n.add(u),this.collisionSystem&&this.collisionSystem.addCollisionObject(u,"building");const p=new j(.7*Math.max(i,o),.3*s,8),g=new C(p),y=new L(g,this.materials.roof);y.position.set(t,s+.15*s,e),y.rotation.y=Math.PI/4,n.add(y);const w=[new h(-.4,0,0),new h(-.4,1.8,0),new h(.4,1.8,0),new h(.4,0,0),new h(-.4,0,0)],v=(new m).setFromPoints(w),x=new k(v,this.materials.building);x.position.set(t,0,e+o/2+.05),n.add(x);const b=[new h(-.3,-.3,0),new h(-.3,.3,0),new h(.3,.3,0),new h(.3,-.3,0),new h(-.3,-.3,0)],z=(new m).setFromPoints(b),S=new k(z,this.materials.building);S.position.set(t+.3*i,.6*s,e+o/2+.02),n.add(S);const P=new k(z,this.materials.building);P.position.set(t+i/2+.02,.6*s,e),P.rotation.y=Math.PI/2,n.add(P),this.gameScene.add(n)}generateTrees(){[{x:5,z:5},{x:-12,z:3},{x:18,z:-8},{x:-20,z:15},{x:25,z:12},{x:-5,z:-20},{x:15,z:20},{x:-18,z:-12},{x:30,z:-15},{x:-25,z:20},{x:8,z:-25},{x:-30,z:8}].forEach(t=>{this.createTree(t.x,t.z)})}createTree(t,e){const i=new l,s=2+2*Math.random(),o=new S(.2,.3,s,8),n=new C(o),a=new L(n,this.materials.trunk);a.position.set(t,s/2,e),i.add(a);const c=new r(o,new R({visible:!1}));c.position.set(t,s/2,e),i.add(c),this.collisionSystem&&this.collisionSystem.addCollisionObject(c,"tree");const h=1.5+1*Math.random(),d=new P(h,12,8),m=new C(d),u=new L(m,this.materials.tree);u.position.set(t,s+.7*h,e),i.add(u),this.gameScene.add(i)}generateDecorations(){for(let t=0;t<20;t++){const t=80*(Math.random()-.5),e=80*(Math.random()-.5);this.isNearBuilding(t,e,5)||this.createStone(t,e)}for(let t=0;t<15;t++){const t=70*(Math.random()-.5),e=70*(Math.random()-.5);this.isNearBuilding(t,e,3)||this.createDecoration(t,e)}}createStone(t,e){const i=new l,s=.3+.7*Math.random(),o=new P(s,8,6),n=new C(o),a=new L(n,this.materials.stone);a.position.set(t,.7*s,e),a.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI),i.add(a);const c=new r(o,new R({visible:!1}));c.position.set(t,.7*s,e),c.rotation.copy(a.rotation),i.add(c),this.gameScene.add(i),this.collisionSystem&&this.collisionSystem.addCollisionObject(c,"decoration")}createDecoration(t,e){const i=Math.floor(3*Math.random()),s=new l;switch(i){case 0:const i=new P(.5,8,6),o=new C(i),n=new L(o,this.materials.tree);n.position.set(t,.3,e),n.scale.set(1,.6,1),s.add(n);const a=new r(i,new R({visible:!1}));a.position.set(t,.3,e),a.scale.set(1,.6,1),s.add(a),this.collisionSystem&&this.collisionSystem.addCollisionObject(a,"decoration");break;case 1:const c=new S(.1,.15,1,8),h=new C(c),l=new L(h,this.materials.stone);l.position.set(t,.5,e),s.add(l);const d=new r(c,new R({visible:!1}));d.position.set(t,.5,e),s.add(d),this.collisionSystem&&this.collisionSystem.addCollisionObject(d,"decoration");break;case 2:const m=new M(.4,.4,.4),u=new C(m),p=new L(u,this.materials.building);p.position.set(t,.2,e),p.rotation.y=Math.random()*Math.PI,s.add(p);const g=new r(m,new R({visible:!1}));g.position.set(t,.2,e),g.rotation.y=p.rotation.y,s.add(g),this.collisionSystem&&this.collisionSystem.addCollisionObject(g,"decoration")}this.gameScene.add(s)}generateRoads(){this.createRoad(0,0,60,2,0),this.createRoad(0,0,2,60,Math.PI/2),this.createRoad(20,0,30,1.5,0),this.createRoad(-20,0,30,1.5,0),this.createRoad(0,20,1.5,30,Math.PI/2),this.createRoad(0,-20,1.5,30,Math.PI/2)}createRoad(t,e,i,s,o){const n=new f(i,s),a=new r(n,this.materials.road);a.position.set(t,.01,e),a.rotation.x=-Math.PI/2,a.rotation.z=o,a.receiveShadow=!0,this.gameScene.add(a)}generateWater(){const t=new B(5,16),e=new r(t,this.materials.water);e.position.set(-30,.1,30),e.rotation.x=-Math.PI/2,this.gameScene.add(e);const i=new f(3,40),s=new r(i,this.materials.water);s.position.set(35,.05,0),s.rotation.x=-Math.PI/2,this.gameScene.add(s)}isNearBuilding(t,e,i){return[{x:10,z:10},{x:-15,z:8},{x:20,z:-10},{x:-8,z:-15},{x:0,z:25},{x:-25,z:-5}].some(s=>Math.sqrt((t-s.x)**2+(e-s.z)**2)<i)}dispose(){Object.values(this.materials).forEach(t=>{t.dispose()}),Object.values(this.geometries).forEach(t=>{t.dispose()})}getGroundHeight(t,e){return Math.sin(.1*t)*Math.cos(.1*e)*.5}checkCollision(t,e){return[{x:10,z:10,size:4},{x:-15,z:8,size:6},{x:20,z:-10,size:3},{x:-8,z:-15,size:5},{x:0,z:25,size:8},{x:-25,z:-5,size:7}].some(i=>Math.sqrt((t.x-i.x)**2+(t.z-i.z)**2)<i.size/2+e)}}const Y={class:"openworld-game"},Z={key:0,class:"game-controls"},J={key:1,class:"game-ui"},Q={class:"ui-top"},$={class:"fps-counter"},tt={class:"top-controls"},et={class:"ui-bottom"},it={class:"minimap-container"},st={class:"position-info"},ot={key:2,class:"loading-overlay"},nt=W(A({__name:"OpenWorldGame",setup(t){const e=T(),i=T(),s=T(),o=T(!1),n=T(!1),a=T(0),r=T({x:0,z:0}),c=T(!1);let h=null,l=null,d=null,m=null,u=null,p=0,g=0;async function y(){if(i.value&&e.value){n.value=!0,o.value=!0;try{h=new q(i.value),await h.init();const t=l?.getCollisionSystem();d=new X(h,t),d.generateWorld(),l=new N(h,e.value),l.init(),s.value&&(u=s.value.getContext("2d")),function(){const t=e=>{if(!h||!l)return;g++,e-p>=1e3&&(a.value=Math.round(1e3*g/(e-p)),g=0,p=e),l.update();const i=l.getPosition();r.value={x:i.x,z:i.z},function(){if(!(u&&l&&d&&s.value))return;const t=120,e=100,i=t/e;u.fillStyle="#2F4F2F",u.fillRect(0,0,t,t),u.strokeStyle="#fff",u.lineWidth=1,u.strokeRect(0,0,t,t);const o=[{x:10,z:10,size:4},{x:-15,z:8,size:6},{x:20,z:-10,size:3},{x:-8,z:-15,size:5},{x:0,z:25,size:8},{x:-25,z:-5,size:7}];u.fillStyle="#8B4513",o.forEach(t=>{const s=(t.x+e/2)*i-t.size*i/2,o=(t.z+e/2)*i-t.size*i/2;u&&u.fillRect(s,o,t.size*i,t.size*i)});const n=l.getPosition(),a=(n.x+e/2)*i,r=(n.z+e/2)*i;u.fillStyle="#ff0000",u.beginPath(),u.arc(a,r,3,0,2*Math.PI),u.fill();const c=l.getDirection();u.strokeStyle="#ff0000",u.lineWidth=2,u.beginPath(),u.moveTo(a,r),u.lineTo(a+10*c.x,r+10*c.z),u.stroke()}(),h.render(),m=requestAnimationFrame(t)};m=requestAnimationFrame(t)}(),n.value=!1}catch(t){n.value=!1,o.value=!1}}}function w(){m&&(cancelAnimationFrame(m),m=null),l&&(l.dispose(),l=null),h&&(h.dispose(),h=null),d=null,o.value=!1,n.value=!1}function v(){document.fullscreenElement?(document.exitFullscreen(),c.value=!1):(e.value?.requestFullscreen(),c.value=!0)}function x(){h&&i.value&&h.handleResize()}return E(()=>{window.addEventListener("resize",x)}),D(()=>{window.removeEventListener("resize",x),w()}),(t,h)=>(F(),G("div",Y,[o.value?I("",!0):(F(),G("div",Z,[O("div",{class:"controls-panel"},[h[0]||(h[0]=H('<h3 class="controls-title" data-v-5a599116>开放世界游戏</h3><div class="controls-info" data-v-5a599116><p class="control-item" data-v-5a599116><kbd data-v-5a599116>W A S D</kbd> - 移动</p><p class="control-item" data-v-5a599116><kbd data-v-5a599116>空格</kbd> - 跳跃</p><p class="control-item" data-v-5a599116><kbd data-v-5a599116>鼠标</kbd> - 视角控制</p><p class="control-item" data-v-5a599116><kbd data-v-5a599116>ESC</kbd> - 退出鼠标锁定</p></div>',2)),O("button",{onClick:y,class:"start-button"}," 开始游戏 ")])])),O("div",{ref_key:"gameContainer",ref:e,class:K(["game-container",{"game-active":o.value}])},[O("canvas",{ref_key:"gameCanvas",ref:i,class:"game-canvas"},null,512)],2),o.value?(F(),G("div",J,[O("div",Q,[O("div",$,"FPS: "+V(a.value),1),O("div",tt,[O("button",{onClick:v,class:"fullscreen-button"},V(c.value?"退出全屏":"全屏模式"),1),O("button",{onClick:w,class:"exit-button"}," 退出游戏 ")])]),O("div",et,[O("div",it,[h[1]||(h[1]=O("div",{class:"minimap-title"},"小地图",-1)),O("canvas",{ref_key:"minimapCanvas",ref:s,class:"minimap",width:"120",height:"120"},null,512)]),O("div",st," 位置: ("+V(Math.round(r.value.x))+", "+V(Math.round(r.value.z))+") ",1)])])):I("",!0),n.value?(F(),G("div",ot,h[2]||(h[2]=[O("div",{class:"loading-content"},[O("div",{class:"loading-spinner"}),O("p",{class:"loading-text"},"正在加载3D世界...")],-1)]))):I("",!0)]))}}),[["__scopeId","data-v-5a599116"]]);export{nt as default};
