import{S as e,P as t,W as i,D as s,e as o,f as n,F as a,M as r,R as c,V as h,G as l,C as d,B as m,a as u,b as p,A as g,c as y,g as w,h as v,E as x,L as b,i as z,j as M,k as S,l as P,m as f,n as k,o as C,d as L,p as R,q as j,r as B}from"./three.module-DnDcNbJQ.js";import{s as A,r as T,C as E,D,l as G,q as F,u as I,p as O,V as H,B as K,A as V}from"./vue-CtS7YL1H.js";import{_ as W}from"./index-BLrTo2Xg.js";import"./vendor-D2VjgEpL.js";import"./gun-BMsQDwI5.js";class q{scene;camera;renderer;canvas;lights;constructor(n){this.canvas=n,this.scene=new e,this.camera=new t,this.renderer=new i({canvas:n}),this.lights={ambient:new o,directional:new s}}async init(){this.setupRenderer(),this.setupCamera(),this.setupLights(),this.setupScene()}setupRenderer(){const e=this.canvas.getBoundingClientRect();this.renderer.setSize(e.width,e.height),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.shadowMap.enabled=!1,this.renderer.setClearColor(0,1),this.renderer.outputColorSpace=n}setupCamera(){const e=this.canvas.getBoundingClientRect();this.camera.fov=75,this.camera.aspect=e.width/e.height,this.camera.near=.1,this.camera.far=1e3,this.camera.position.set(0,5,10),this.camera.updateProjectionMatrix()}setupLights(){this.lights.ambient.color.setHex(16777215),this.lights.ambient.intensity=.8,this.scene.add(this.lights.ambient),this.lights.directional.color.setHex(16777215),this.lights.directional.intensity=.3,this.lights.directional.position.set(50,100,50),this.lights.directional.castShadow=!1,this.scene.add(this.lights.directional)}setupScene(){this.scene.fog=new a(0,30,150)}add(e){this.scene.add(e)}remove(e){this.scene.remove(e)}getCamera(){return this.camera}getScene(){return this.scene}getRenderer(){return this.renderer}render(){this.renderer.render(this.scene,this.camera)}handleResize(){const e=this.canvas.getBoundingClientRect();this.camera.aspect=e.width/e.height,this.camera.updateProjectionMatrix(),this.renderer.setSize(e.width,e.height),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}dispose(){this.scene.traverse(e=>{e instanceof r&&(e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose()))}),this.renderer.dispose()}raycast(e,t,i){return new c(e,t).intersectObjects(i||this.scene.children,!0)}screenToWorld(e,t,i=0){const s=new h(e,t,i);return s.unproject(this.camera),s}updateLighting(e){const t=(Math.sin(.001*e)+1)/2;this.lights.ambient.intensity=.2+.3*t,this.lights.directional.intensity=.5+.5*t,t<.3?this.lights.directional.color.setHex(4286945):t<.7?this.lights.directional.color.setHex(16737095):this.lights.directional.color.setHex(16777215)}}class U{group;particles=[];particleGeometries=[];particleMaterials=[];trailParticles=[];trailPositions=[];velocity=new h;isMoving=!1;trailParticleCount=12;maxTrailLength=20;particleSpread=.2;constructor(){this.group=new l,this.createTrailSystem()}createParticleTexture(){const e=document.createElement("canvas");e.width=32,e.height=32;const t=e.getContext("2d");t.clearRect(0,0,32,32);const i=t.createRadialGradient(16,16,0,16,16,16);i.addColorStop(0,"rgba(255, 255, 255, 0.8)"),i.addColorStop(.2,"rgba(255, 255, 255, 0.6)"),i.addColorStop(.5,"rgba(255, 255, 255, 0.3)"),i.addColorStop(.8,"rgba(255, 255, 255, 0.1)"),i.addColorStop(1,"rgba(255, 255, 255, 0)"),t.fillStyle=i,t.fillRect(0,0,32,32);const s=new d(e);return s.needsUpdate=!0,s}createTrailSystem(){for(let e=0;e<this.trailParticleCount;e++){const e=new Float32Array(3*this.maxTrailLength),t=new Float32Array(3*this.maxTrailLength),i=new Float32Array(this.maxTrailLength);for(let a=0;a<this.maxTrailLength;a++){e[3*a]=0,e[3*a+1]=0,e[3*a+2]=0;const s=1-a/this.maxTrailLength;t[3*a]=.8*s,t[3*a+1]=.8*s,t[3*a+2]=.8*s,i[a]=2*s}const s=new m;s.setAttribute("position",new u(e,3)),s.setAttribute("color",new u(t,3)),s.setAttribute("size",new u(i,1));const o=new p({size:3,sizeAttenuation:!0,vertexColors:!0,transparent:!0,opacity:.7,blending:g,map:this.createParticleTexture(),alphaTest:.1}),n=new y(s,o);this.trailParticles.push(n),this.trailPositions.push([]),this.group.add(n)}}update(e,t){this.velocity.copy(t),this.isMoving=t.length()>.01,this.updateTrailParticles(e)}updateTrailParticles(e){const t=this.group.position.clone(),i=.001*Date.now();this.trailParticles.forEach((e,s)=>{const o=s/this.trailParticleCount*Math.PI*2,n=new h(Math.cos(o+i)*this.particleSpread,.1*Math.sin(2*i+s),Math.sin(o+i)*this.particleSpread);if(this.isMoving){const e=this.velocity.clone().multiplyScalar(-.2*(s+1));n.add(e)}const a=t.clone().add(n);this.trailPositions[s].unshift(a),this.trailPositions[s].length>this.maxTrailLength&&this.trailPositions[s].pop();const r=e.geometry.attributes.position.array,c=e.geometry.attributes.color.array,l=e.geometry.attributes.size.array;for(let t=0;t<this.maxTrailLength;t++)if(t<this.trailPositions[s].length){const e=this.trailPositions[s][t];r[3*t]=e.x,r[3*t+1]=e.y,r[3*t+2]=e.z;const o=1-t/this.maxTrailLength,n=o*(.8+.2*Math.sin(3*i+s));c[3*t]=n,c[3*t+1]=n,c[3*t+2]=n,l[t]=o*(2+1*Math.sin(2*i+.5*t))}else r[3*t]=0,r[3*t+1]=0,r[3*t+2]=0,c[3*t]=0,c[3*t+1]=0,c[3*t+2]=0,l[t]=0;e.geometry.attributes.position.needsUpdate=!0,e.geometry.attributes.color.needsUpdate=!0,e.geometry.attributes.size.needsUpdate=!0})}getGroup(){return this.group}setPosition(e){this.group.position.copy(e)}getPosition(){return this.group.position}dispose(){this.particleGeometries.forEach(e=>e.dispose()),this.particleMaterials.forEach(e=>e.dispose()),this.trailParticles.forEach(e=>{e.geometry.dispose(),e.material instanceof w&&e.material.dispose()}),this.particles.length=0,this.trailParticles.length=0,this.trailPositions.length=0}}class _{collisionObjects=[];playerBoundingBox=new v;tempBox=new v;tempVector=new h;playerRadius=.5;playerHeight=1.8;constructor(){this.updatePlayerBoundingBox(new h(0,0,0))}addCollisionObject(e,t){const i=(new v).setFromObject(e);switch(t){case"building":break;case"tree":i.max.y=i.min.y+.5;break;case"decoration":const e=.2;i.min.add(new h(e,0,e)),i.max.sub(new h(e,0,e))}this.collisionObjects.push({mesh:e,boundingBox:i,type:t})}updatePlayerBoundingBox(e){this.playerBoundingBox.setFromCenterAndSize(new h(e.x,e.y+this.playerHeight/2,e.z),new h(2*this.playerRadius,this.playerHeight,2*this.playerRadius))}checkCollision(e){this.updatePlayerBoundingBox(e);for(const t of this.collisionObjects)if(this.playerBoundingBox.intersectsBox(t.boundingBox))switch(t.type){case"water":return{hasCollision:!1};case"building":case"tree":case"decoration":const i=this.resolveCollision(e,t.boundingBox);return{hasCollision:!0,collisionType:t.type,adjustedPosition:i}}return{hasCollision:!1}}resolveCollision(e,t){const i=e.clone(),s=new h(e.x,e.y+this.playerHeight/2,e.z),o=t.getCenter(this.tempVector),n=new h;n.subVectors(s,o),n.y=0,0===n.length()&&n.set(1,0,0),n.normalize();const a=new h;t.getSize(a).multiplyScalar(.5);const r=this.playerRadius+Math.max(a.x,a.z)+.1;return i.x=o.x+n.x*r,i.z=o.z+n.z*r,i}checkRayCollision(e,t,i){const s=new c(e,t,0,i);let o=i;for(const n of this.collisionObjects){if("water"===n.type)continue;const t=new h;if(s.ray.intersectBox(n.boundingBox,t)){const i=e.distanceTo(t);i<o&&(o=i)}}return o}getGroundHeight(e,t){let i=0;for(const s of this.collisionObjects)if("building"===s.type){const o=s.boundingBox;e>=o.min.x&&e<=o.max.x&&t>=o.min.z&&t<=o.max.z&&(i=Math.max(i,o.max.y))}return i}clear(){this.collisionObjects=[]}getCollisionObjects(){return this.collisionObjects}setPlayerSize(e,t){this.playerRadius=e,this.playerHeight=t}}class N{gameScene;container;camera;player;collisionSystem;position;velocity;direction;rotation;cameraDistance=8;cameraHeight=4;cameraTarget=new h;keys={};mouseMovement={x:0,y:0};isPointerLocked=!1;moveSpeed=5;jumpForce=8;gravity=-20;mouseSensitivity=.002;verticalAngle=0;maxVerticalAngle=Math.PI/3;minVerticalAngle=-Math.PI/6;isGrounded=!0;playerHeight=1.8;playerRadius=.5;boundKeyDown;boundKeyUp;boundMouseMove;boundPointerLockChange;boundClick;constructor(e,t){this.gameScene=e,this.container=t,this.camera=e.getCamera(),this.player=new U,e.add(this.player.getGroup()),this.collisionSystem=new _,this.position=new h(0,5,10),this.velocity=new h(0,0,0),this.direction=new h(0,0,0),this.rotation=new x(0,0,0,"YXZ"),this.boundKeyDown=this.onKeyDown.bind(this),this.boundKeyUp=this.onKeyUp.bind(this),this.boundMouseMove=this.onMouseMove.bind(this),this.boundPointerLockChange=this.onPointerLockChange.bind(this),this.boundClick=this.onClick.bind(this)}init(){this.camera.position.copy(this.position),this.camera.rotation.copy(this.rotation),document.addEventListener("keydown",this.boundKeyDown),document.addEventListener("keyup",this.boundKeyUp),document.addEventListener("mousemove",this.boundMouseMove),document.addEventListener("pointerlockchange",this.boundPointerLockChange),this.container.addEventListener("click",this.boundClick)}onKeyDown(e){this.keys[e.code]=!0,"Space"===e.code&&this.isGrounded&&(this.velocity.y=this.jumpForce,this.isGrounded=!1,e.preventDefault()),"Escape"===e.code&&this.exitPointerLock()}onKeyUp(e){this.keys[e.code]=!1}onMouseMove(e){this.isPointerLocked&&(this.mouseMovement.x=e.movementX||0,this.mouseMovement.y=e.movementY||0,this.rotation.y-=this.mouseMovement.x*this.mouseSensitivity,this.verticalAngle-=this.mouseMovement.y*this.mouseSensitivity,this.verticalAngle=Math.max(this.minVerticalAngle,Math.min(this.maxVerticalAngle,this.verticalAngle)))}onPointerLockChange(){this.isPointerLocked=document.pointerLockElement===this.container}onClick(){this.isPointerLocked||this.requestPointerLock()}requestPointerLock(){this.container.requestPointerLock()}exitPointerLock(){document.exitPointerLock()}update(){const e=1/60;this.updateMouseLook(),this.updateMovement(e),this.applyPhysics(e),this.player.setPosition(this.position),this.player.update(e,this.velocity),this.updateCamera()}updateMouseLook(){this.isPointerLocked&&(this.rotation.y-=this.mouseMovement.x*this.mouseSensitivity,this.rotation.x-=this.mouseMovement.y*this.mouseSensitivity,this.rotation.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.rotation.x)),this.mouseMovement.x=0,this.mouseMovement.y=0)}updateMovement(e){this.direction.set(0,0,0),this.keys.KeyW&&(this.direction.z-=1),this.keys.KeyS&&(this.direction.z+=1),this.keys.KeyA&&(this.direction.x-=1),this.keys.KeyD&&(this.direction.x+=1),this.direction.length()>0&&this.direction.normalize();const t=new h;this.camera.getWorldDirection(t);const i=new h;i.crossVectors(t,this.camera.up).normalize();const s=new h;s.crossVectors(this.camera.up,i).normalize();const o=new h;o.addScaledVector(i,this.direction.x),o.addScaledVector(s,-this.direction.z),o.length()>0?(o.normalize(),this.velocity.x=o.x*this.moveSpeed,this.velocity.z=o.z*this.moveSpeed):(this.velocity.x*=.8,this.velocity.z*=.8)}applyPhysics(e){this.isGrounded||(this.velocity.y+=this.gravity*e);const t=new h(this.velocity.x,0,this.velocity.z),i=new h(0,this.velocity.y,0),s=this.position.clone();s.addScaledVector(t,e);const o=this.collisionSystem.checkCollision(s);o.hasCollision&&o.adjustedPosition?(this.position.x=o.adjustedPosition.x,this.position.z=o.adjustedPosition.z,this.velocity.x=0,this.velocity.z=0):(this.position.x=s.x,this.position.z=s.z);const n=this.position.clone();n.addScaledVector(i,e);const a=this.collisionSystem.getGroundHeight(this.position.x,this.position.z);n.y<=a+this.playerHeight?(this.position.y=a+this.playerHeight,this.velocity.y=0,this.isGrounded=!0):(this.position.y=n.y,this.isGrounded=!1);this.position.x=Math.max(-50,Math.min(50,this.position.x)),this.position.z=Math.max(-50,Math.min(50,this.position.z))}getGroundLevel(e,t){return 0}updateCamera(){const e=this.cameraDistance*Math.cos(this.verticalAngle),t=this.cameraHeight+this.cameraDistance*Math.sin(this.verticalAngle),i=new h(Math.sin(this.rotation.y)*e,t,Math.cos(this.rotation.y)*e);this.position.clone().add(i);const s=i.clone().normalize(),o=this.collisionSystem.checkRayCollision(this.position.clone().add(new h(0,1.5,0)),s,this.cameraDistance);let n=Math.min(o-.5,this.cameraDistance);n=Math.max(n,1);const a=n*Math.cos(this.verticalAngle),r=this.cameraHeight+n*Math.sin(this.verticalAngle),c=new h(Math.sin(this.rotation.y)*a,r,Math.cos(this.rotation.y)*a);this.camera.position.copy(this.position).add(c),this.cameraTarget.copy(this.position),this.cameraTarget.y+=1.5,this.camera.lookAt(this.cameraTarget)}getPosition(){return this.position.clone()}setPosition(e){this.position.copy(e),this.camera.position.copy(this.position)}getDirection(){const e=new h;return this.camera.getWorldDirection(e),e}getIsGrounded(){return this.isGrounded}getVelocity(){return this.velocity.clone()}setMoveSpeed(e){this.moveSpeed=e}setMouseSensitivity(e){this.mouseSensitivity=e}getPlayerMesh(){return this.player.getGroup()}getCollisionSystem(){return this.collisionSystem}dispose(){document.removeEventListener("keydown",this.boundKeyDown),document.removeEventListener("keyup",this.boundKeyUp),document.removeEventListener("mousemove",this.boundMouseMove),document.removeEventListener("pointerlockchange",this.boundPointerLockChange),this.container.removeEventListener("click",this.boundClick),this.isPointerLocked&&this.exitPointerLock(),this.gameScene.remove(this.player.getGroup()),this.player.dispose(),this.collisionSystem.clear()}}class X{gameScene;scene;collisionSystem=null;materials={};geometries={};constructor(e,t){this.gameScene=e,this.scene=e.getScene(),this.collisionSystem=t||null,this.initMaterials(),this.initGeometries()}initMaterials(){this.materials.ground=new b({color:3355443,transparent:!0,opacity:.6}),this.materials.building=new b({color:16777215,transparent:!0,opacity:.8}),this.materials.roof=new b({color:13421772,transparent:!0,opacity:.7}),this.materials.tree=new b({color:8947848,transparent:!0,opacity:.6}),this.materials.trunk=new b({color:11184810,transparent:!0,opacity:.7}),this.materials.stone=new b({color:10066329,transparent:!0,opacity:.5}),this.materials.water=new z({color:27028,transparent:!0,opacity:.7}),this.materials.road=new z({color:3092271})}initGeometries(){this.geometries.box=new M(1,1,1),this.geometries.cylinder=new S(1,1,1,8),this.geometries.sphere=new P(1,8,6),this.geometries.plane=new f(1,1)}generateWorld(){this.generateGround(),this.generateBuildings(),this.generateTrees(),this.generateDecorations(),this.generateRoads(),this.generateWater()}generateGround(){const e=new l;for(let t=0;t<=50;t++){const i=[],s=2*t-50;i.push(new h(-50,0,s)),i.push(new h(50,0,s));const o=(new m).setFromPoints(i),n=new k(o,this.materials.ground);e.add(n)}for(let t=0;t<=50;t++){const i=[],s=2*t-50;i.push(new h(s,0,-50)),i.push(new h(s,0,50));const o=(new m).setFromPoints(i),n=new k(o,this.materials.ground);e.add(n)}this.gameScene.add(e)}generateBuildings(){[{x:10,z:10,width:4,height:3,depth:4},{x:-15,z:8,width:6,height:4,depth:5},{x:20,z:-10,width:3,height:5,depth:3},{x:-8,z:-15,width:5,height:3,depth:4},{x:0,z:25,width:8,height:6,depth:6},{x:-25,z:-5,width:7,height:8,depth:5}].forEach(e=>{this.createBuilding(e.x,e.z,e.width,e.height,e.depth)})}createBuilding(e,t,i,s,o){const n=new l,a=new M(i,s,o),c=new C(a),d=new L(c,this.materials.building);d.position.set(e,s/2,t),n.add(d);const u=new r(a,new R({visible:!1}));u.position.set(e,s/2,t),n.add(u),this.collisionSystem&&this.collisionSystem.addCollisionObject(u,"building");const p=new j(.7*Math.max(i,o),.3*s,8),g=new C(p),y=new L(g,this.materials.roof);y.position.set(e,s+.15*s,t),y.rotation.y=Math.PI/4,n.add(y);const w=[new h(-.4,0,0),new h(-.4,1.8,0),new h(.4,1.8,0),new h(.4,0,0),new h(-.4,0,0)],v=(new m).setFromPoints(w),x=new k(v,this.materials.building);x.position.set(e,0,t+o/2+.05),n.add(x);const b=[new h(-.3,-.3,0),new h(-.3,.3,0),new h(.3,.3,0),new h(.3,-.3,0),new h(-.3,-.3,0)],z=(new m).setFromPoints(b),S=new k(z,this.materials.building);S.position.set(e+.3*i,.6*s,t+o/2+.02),n.add(S);const P=new k(z,this.materials.building);P.position.set(e+i/2+.02,.6*s,t),P.rotation.y=Math.PI/2,n.add(P),this.gameScene.add(n)}generateTrees(){[{x:5,z:5},{x:-12,z:3},{x:18,z:-8},{x:-20,z:15},{x:25,z:12},{x:-5,z:-20},{x:15,z:20},{x:-18,z:-12},{x:30,z:-15},{x:-25,z:20},{x:8,z:-25},{x:-30,z:8}].forEach(e=>{this.createTree(e.x,e.z)})}createTree(e,t){const i=new l,s=2+2*Math.random(),o=new S(.2,.3,s,8),n=new C(o),a=new L(n,this.materials.trunk);a.position.set(e,s/2,t),i.add(a);const c=new r(o,new R({visible:!1}));c.position.set(e,s/2,t),i.add(c),this.collisionSystem&&this.collisionSystem.addCollisionObject(c,"tree");const h=1.5+1*Math.random(),d=new P(h,12,8),m=new C(d),u=new L(m,this.materials.tree);u.position.set(e,s+.7*h,t),i.add(u),this.gameScene.add(i)}generateDecorations(){for(let e=0;e<20;e++){const e=80*(Math.random()-.5),t=80*(Math.random()-.5);this.isNearBuilding(e,t,5)||this.createStone(e,t)}for(let e=0;e<15;e++){const e=70*(Math.random()-.5),t=70*(Math.random()-.5);this.isNearBuilding(e,t,3)||this.createDecoration(e,t)}}createStone(e,t){const i=new l,s=.3+.7*Math.random(),o=new P(s,8,6),n=new C(o),a=new L(n,this.materials.stone);a.position.set(e,.7*s,t),a.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI),i.add(a);const c=new r(o,new R({visible:!1}));c.position.set(e,.7*s,t),c.rotation.copy(a.rotation),i.add(c),this.gameScene.add(i),this.collisionSystem&&this.collisionSystem.addCollisionObject(c,"decoration")}createDecoration(e,t){const i=Math.floor(3*Math.random()),s=new l;switch(i){case 0:const i=new P(.5,8,6),o=new C(i),n=new L(o,this.materials.tree);n.position.set(e,.3,t),n.scale.set(1,.6,1),s.add(n);const a=new r(i,new R({visible:!1}));a.position.set(e,.3,t),a.scale.set(1,.6,1),s.add(a),this.collisionSystem&&this.collisionSystem.addCollisionObject(a,"decoration");break;case 1:const c=new S(.1,.15,1,8),h=new C(c),l=new L(h,this.materials.stone);l.position.set(e,.5,t),s.add(l);const d=new r(c,new R({visible:!1}));d.position.set(e,.5,t),s.add(d),this.collisionSystem&&this.collisionSystem.addCollisionObject(d,"decoration");break;case 2:const m=new M(.4,.4,.4),u=new C(m),p=new L(u,this.materials.building);p.position.set(e,.2,t),p.rotation.y=Math.random()*Math.PI,s.add(p);const g=new r(m,new R({visible:!1}));g.position.set(e,.2,t),g.rotation.y=p.rotation.y,s.add(g),this.collisionSystem&&this.collisionSystem.addCollisionObject(g,"decoration")}this.gameScene.add(s)}generateRoads(){this.createRoad(0,0,60,2,0),this.createRoad(0,0,2,60,Math.PI/2),this.createRoad(20,0,30,1.5,0),this.createRoad(-20,0,30,1.5,0),this.createRoad(0,20,1.5,30,Math.PI/2),this.createRoad(0,-20,1.5,30,Math.PI/2)}createRoad(e,t,i,s,o){const n=new f(i,s),a=new r(n,this.materials.road);a.position.set(e,.01,t),a.rotation.x=-Math.PI/2,a.rotation.z=o,a.receiveShadow=!0,this.gameScene.add(a)}generateWater(){const e=new B(5,16),t=new r(e,this.materials.water);t.position.set(-30,.1,30),t.rotation.x=-Math.PI/2,this.gameScene.add(t);const i=new f(3,40),s=new r(i,this.materials.water);s.position.set(35,.05,0),s.rotation.x=-Math.PI/2,this.gameScene.add(s)}isNearBuilding(e,t,i){return[{x:10,z:10},{x:-15,z:8},{x:20,z:-10},{x:-8,z:-15},{x:0,z:25},{x:-25,z:-5}].some(s=>Math.sqrt((e-s.x)**2+(t-s.z)**2)<i)}dispose(){Object.values(this.materials).forEach(e=>{e.dispose()}),Object.values(this.geometries).forEach(e=>{e.dispose()})}getGroundHeight(e,t){return Math.sin(.1*e)*Math.cos(.1*t)*.5}checkCollision(e,t){return[{x:10,z:10,size:4},{x:-15,z:8,size:6},{x:20,z:-10,size:3},{x:-8,z:-15,size:5},{x:0,z:25,size:8},{x:-25,z:-5,size:7}].some(i=>Math.sqrt((e.x-i.x)**2+(e.z-i.z)**2)<i.size/2+t)}}const Y={class:"openworld-game"},Z={key:0,class:"game-controls"},J={key:1,class:"game-ui"},Q={class:"ui-top"},$={class:"fps-counter"},ee={class:"top-controls"},te={class:"ui-bottom"},ie={class:"minimap-container"},se={class:"position-info"},oe={key:2,class:"loading-overlay"},ne=W(A({__name:"OpenWorldGame",setup(e){const t=T(),i=T(),s=T(),o=T(!1),n=T(!1),a=T(0),r=T({x:0,z:0}),c=T(!1);let h=null,l=null,d=null,m=null,u=null,p=0,g=0;async function y(){if(i.value&&t.value){n.value=!0,o.value=!0;try{h=new q(i.value),await h.init();const e=l?.getCollisionSystem();d=new X(h,e),d.generateWorld(),l=new N(h,t.value),l.init(),s.value&&(u=s.value.getContext("2d")),function(){const e=t=>{if(!h||!l)return;g++,t-p>=1e3&&(a.value=Math.round(1e3*g/(t-p)),g=0,p=t),l.update();const i=l.getPosition();r.value={x:i.x,z:i.z},function(){if(!(u&&l&&d&&s.value))return;const e=120,t=100,i=e/t;u.fillStyle="#2F4F2F",u.fillRect(0,0,e,e),u.strokeStyle="#fff",u.lineWidth=1,u.strokeRect(0,0,e,e);const o=[{x:10,z:10,size:4},{x:-15,z:8,size:6},{x:20,z:-10,size:3},{x:-8,z:-15,size:5},{x:0,z:25,size:8},{x:-25,z:-5,size:7}];u.fillStyle="#8B4513",o.forEach(e=>{const s=(e.x+t/2)*i-e.size*i/2,o=(e.z+t/2)*i-e.size*i/2;u.fillRect(s,o,e.size*i,e.size*i)});const n=l.getPosition(),a=(n.x+t/2)*i,r=(n.z+t/2)*i;u.fillStyle="#ff0000",u.beginPath(),u.arc(a,r,3,0,2*Math.PI),u.fill();const c=l.getDirection();u.strokeStyle="#ff0000",u.lineWidth=2,u.beginPath(),u.moveTo(a,r),u.lineTo(a+10*c.x,r+10*c.z),u.stroke()}(),h.render(),m=requestAnimationFrame(e)};m=requestAnimationFrame(e)}(),n.value=!1}catch(e){n.value=!1,o.value=!1}}}function w(){m&&(cancelAnimationFrame(m),m=null),l&&(l.dispose(),l=null),h&&(h.dispose(),h=null),d=null,o.value=!1,n.value=!1}function v(){document.fullscreenElement?(document.exitFullscreen(),c.value=!1):(t.value?.requestFullscreen(),c.value=!0)}function x(){h&&i.value&&h.handleResize()}return E(()=>{window.addEventListener("resize",x)}),D(()=>{window.removeEventListener("resize",x),w()}),(e,h)=>(F(),G("div",Y,[o.value?I("",!0):(F(),G("div",Z,[O("div",{class:"controls-panel"},[h[0]||(h[0]=H('<h3 class="controls-title" data-v-6c7bec21>开放世界游戏</h3><div class="controls-info" data-v-6c7bec21><p class="control-item" data-v-6c7bec21><kbd data-v-6c7bec21>W A S D</kbd> - 移动</p><p class="control-item" data-v-6c7bec21><kbd data-v-6c7bec21>空格</kbd> - 跳跃</p><p class="control-item" data-v-6c7bec21><kbd data-v-6c7bec21>鼠标</kbd> - 视角控制</p><p class="control-item" data-v-6c7bec21><kbd data-v-6c7bec21>ESC</kbd> - 退出鼠标锁定</p></div>',2)),O("button",{onClick:y,class:"start-button"}," 开始游戏 ")])])),O("div",{ref_key:"gameContainer",ref:t,class:K(["game-container",{"game-active":o.value}])},[O("canvas",{ref_key:"gameCanvas",ref:i,class:"game-canvas"},null,512)],2),o.value?(F(),G("div",J,[O("div",Q,[O("div",$,"FPS: "+V(a.value),1),O("div",ee,[O("button",{onClick:v,class:"fullscreen-button"},V(c.value?"退出全屏":"全屏模式"),1),O("button",{onClick:w,class:"exit-button"}," 退出游戏 ")])]),O("div",te,[O("div",ie,[h[1]||(h[1]=O("div",{class:"minimap-title"},"小地图",-1)),O("canvas",{ref_key:"minimapCanvas",ref:s,class:"minimap",width:"120",height:"120"},null,512)]),O("div",se," 位置: ("+V(Math.round(r.value.x))+", "+V(Math.round(r.value.z))+") ",1)])])):I("",!0),n.value?(F(),G("div",oe,h[2]||(h[2]=[O("div",{class:"loading-content"},[O("div",{class:"loading-spinner"}),O("p",{class:"loading-text"},"正在加载3D世界...")],-1)]))):I("",!0)]))}}),[["__scopeId","data-v-6c7bec21"]]);export{ne as default};
